import { TemplateRef, Component, ChangeDetectionStrategy, ChangeDetectorRef, Input, EventEmitter, Directive, ElementRef, Output, NgModule } from '@angular/core';
import { OverlayConfig, Overlay, OverlayPositionBuilder, OverlayModule } from '@angular/cdk/overlay';
import { ComponentPortal } from '@angular/cdk/portal';
import { trigger, state, style, transition, animate } from '@angular/animations';
import { Subject, fromEvent } from 'rxjs';
import { takeUntil, first } from 'rxjs/operators';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/cdk/overlay';

function MdbPopoverComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.title, " ");
} }
function MdbPopoverComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵelementContainer(1, 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.content);
} }
function MdbPopoverComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r2.content, " ");
} }
class MdbPopoverComponent {
    constructor(_cdRef) {
        this._cdRef = _cdRef;
        this._hidden = new Subject();
        this.animationState = 'hidden';
    }
    get isContentTemplate() {
        return this.content instanceof TemplateRef;
    }
    markForCheck() {
        this._cdRef.markForCheck();
    }
    onAnimationEnd(event) {
        if (event.toState === 'hidden') {
            this._hidden.next();
        }
    }
}
MdbPopoverComponent.ɵfac = function MdbPopoverComponent_Factory(t) { return new (t || MdbPopoverComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
MdbPopoverComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MdbPopoverComponent, selectors: [["mdb-popover"]], inputs: { title: "title", content: "content", animation: "animation" }, decls: 4, vars: 5, consts: [[1, "popover"], ["class", "popover-header", 4, "ngIf"], ["class", "popover-body", 4, "ngIf"], [1, "popover-header"], [1, "popover-body"], [3, "ngTemplateOutlet"]], template: function MdbPopoverComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("@fade.done", function MdbPopoverComponent_Template_div_animation_fade_done_0_listener($event) { return ctx.onAnimationEnd($event); });
        ɵngcc0.ɵɵtemplate(1, MdbPopoverComponent_div_1_Template, 2, 1, "div", 1);
        ɵngcc0.ɵɵtemplate(2, MdbPopoverComponent_div_2_Template, 2, 1, "div", 2);
        ɵngcc0.ɵɵtemplate(3, MdbPopoverComponent_div_3_Template, 2, 1, "div", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("@fade", ctx.animationState)("@.disabled", !ctx.animation);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isContentTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isContentTemplate);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], encapsulation: 2, data: { animation: [
            trigger('fade', [
                state('visible', style({ opacity: 1 })),
                state('hidden', style({ opacity: 0 })),
                transition('visible <=> hidden', animate('150ms linear')),
                transition(':enter', animate('150ms linear')),
            ]),
        ] }, changeDetection: 0 });
MdbPopoverComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
MdbPopoverComponent.propDecorators = {
    title: [{ type: Input }],
    content: [{ type: Input }],
    animation: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbPopoverComponent, [{
        type: Component,
        args: [{
                selector: 'mdb-popover',
                template: "<div\n  class=\"popover\"\n  [@fade]=\"animationState\"\n  (@fade.done)=\"onAnimationEnd($event)\"\n  [@.disabled]=\"!animation\"\n>\n  <div *ngIf=\"title\" class=\"popover-header\">\n    {{ title }}\n  </div>\n  <div *ngIf=\"isContentTemplate\" class=\"popover-body\">\n    <ng-container [ngTemplateOutlet]=\"content\"></ng-container>\n  </div>\n  <div *ngIf=\"!isContentTemplate\" class=\"popover-body\">\n    {{ content }}\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('fade', [
                        state('visible', style({ opacity: 1 })),
                        state('hidden', style({ opacity: 0 })),
                        transition('visible <=> hidden', animate('150ms linear')),
                        transition(':enter', animate('150ms linear')),
                    ]),
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { title: [{
            type: Input
        }], content: [{
            type: Input
        }], animation: [{
            type: Input
        }] }); })();

// eslint-disable-next-line @angular-eslint/component-class-suffix
class MdbPopoverDirective {
    constructor(_overlay, _overlayPositionBuilder, _elementRef) {
        this._overlay = _overlay;
        this._overlayPositionBuilder = _overlayPositionBuilder;
        this._elementRef = _elementRef;
        this.mdbPopover = '';
        this.mdbPopoverTitle = '';
        this._popoverDisabled = false;
        this.placement = 'top';
        this._animation = false;
        this.trigger = 'click';
        this.delayShow = 0;
        this.delayHide = 0;
        this.offset = 4;
        this.popoverShow = new EventEmitter();
        this.popoverShown = new EventEmitter();
        this.popoverHide = new EventEmitter();
        this.popoverHidden = new EventEmitter();
        this._open = false;
        this._showTimeout = 0;
        this._hideTimeout = 0;
        this._destroy$ = new Subject();
    }
    get popoverDisabled() {
        return this._popoverDisabled;
    }
    set popoverDisabled(value) {
        this._popoverDisabled = coerceBooleanProperty(value);
    }
    get animation() {
        return this._animation;
    }
    set animation(value) {
        this._animation = coerceBooleanProperty(value);
    }
    ngOnInit() {
        if (this.popoverDisabled) {
            return;
        }
        this._bindTriggerEvents();
    }
    ngOnDestroy() {
        if (this._open) {
            this.hide();
        }
        this._destroy$.next();
        this._destroy$.complete();
    }
    _bindTriggerEvents() {
        const triggers = this.trigger.split(' ');
        triggers.forEach((trigger) => {
            if (trigger === 'click') {
                fromEvent(this._elementRef.nativeElement, trigger)
                    .pipe(takeUntil(this._destroy$))
                    .subscribe(() => this.toggle());
            }
            else if (trigger !== 'manual') {
                const evIn = trigger === 'hover' ? 'mouseenter' : 'focusin';
                const evOut = trigger === 'hover' ? 'mouseleave' : 'focusout';
                fromEvent(this._elementRef.nativeElement, evIn)
                    .pipe(takeUntil(this._destroy$))
                    .subscribe(() => this.show());
                fromEvent(this._elementRef.nativeElement, evOut)
                    .pipe(takeUntil(this._destroy$))
                    .subscribe(() => this.hide());
            }
        });
    }
    _createOverlayConfig() {
        const positionStrategy = this._overlayPositionBuilder
            .flexibleConnectedTo(this._elementRef)
            .withPositions(this._getPosition());
        const overlayConfig = new OverlayConfig({
            hasBackdrop: false,
            scrollStrategy: this._overlay.scrollStrategies.reposition(),
            positionStrategy,
        });
        return overlayConfig;
    }
    _createOverlay() {
        this._overlayRef = this._overlay.create(this._createOverlayConfig());
    }
    _getPosition() {
        let position;
        const positionTop = {
            originX: 'center',
            originY: 'top',
            overlayX: 'center',
            overlayY: 'bottom',
            offsetY: -this.offset,
        };
        const positionBottom = {
            originX: 'center',
            originY: 'bottom',
            overlayX: 'center',
            overlayY: 'top',
            offsetY: this.offset,
        };
        const positionRight = {
            originX: 'end',
            originY: 'center',
            overlayX: 'start',
            overlayY: 'center',
            offsetX: this.offset,
        };
        const positionLeft = {
            originX: 'start',
            originY: 'center',
            overlayX: 'end',
            overlayY: 'center',
            offsetX: -this.offset,
        };
        switch (this.placement) {
            case 'top':
                position = [positionTop, positionBottom];
                break;
            case 'bottom':
                position = [positionBottom, positionTop];
                break;
            case 'left':
                position = [positionLeft, positionRight, positionTop, positionBottom];
                break;
            case 'right':
                position = [positionRight, positionLeft, positionTop, positionBottom];
                break;
            default:
                break;
        }
        return position;
    }
    show() {
        if (this._hideTimeout) {
            this._overlayRef.detach();
            clearTimeout(this._hideTimeout);
            this._hideTimeout = null;
        }
        this._createOverlay();
        if (this._hideTimeout) {
            clearTimeout(this._hideTimeout);
            this._hideTimeout = null;
        }
        this._showTimeout = setTimeout(() => {
            const tooltipPortal = new ComponentPortal(MdbPopoverComponent);
            this.popoverShow.emit(this);
            this._open = true;
            this._tooltipRef = this._overlayRef.attach(tooltipPortal);
            this._tooltipRef.instance.content = this.template || this.mdbPopover;
            this._tooltipRef.instance.title = this.mdbPopoverTitle;
            this._tooltipRef.instance.animation = this.animation;
            this._tooltipRef.instance.animationState = 'visible';
            this._tooltipRef.instance.markForCheck();
            this.popoverShown.emit(this);
        }, this.delayShow);
    }
    hide() {
        if (this._showTimeout) {
            clearTimeout(this._showTimeout);
            this._showTimeout = null;
        }
        else {
            return;
        }
        this._hideTimeout = setTimeout(() => {
            this.popoverHide.emit(this);
            if (!this._tooltipRef) {
                this._overlayRef.detach();
                this._open = false;
                this.popoverHidden.emit(this);
            }
            else {
                this._tooltipRef.instance._hidden.pipe(first()).subscribe(() => {
                    this._overlayRef.detach();
                    this._open = false;
                    this.popoverHidden.emit(this);
                });
                this._tooltipRef.instance.animationState = 'hidden';
                this._tooltipRef.instance.markForCheck();
            }
        }, this.delayHide);
    }
    toggle() {
        if (this._open) {
            this.hide();
        }
        else {
            this.show();
        }
    }
}
MdbPopoverDirective.ɵfac = function MdbPopoverDirective_Factory(t) { return new (t || MdbPopoverDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.OverlayPositionBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
MdbPopoverDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MdbPopoverDirective, selectors: [["", "mdbPopover", ""]], inputs: { mdbPopover: "mdbPopover", mdbPopoverTitle: "mdbPopoverTitle", placement: "placement", trigger: "trigger", delayShow: "delayShow", delayHide: "delayHide", offset: "offset", popoverDisabled: "popoverDisabled", animation: "animation", template: "template" }, outputs: { popoverShow: "popoverShow", popoverShown: "popoverShown", popoverHide: "popoverHide", popoverHidden: "popoverHidden" }, exportAs: ["mdbPopover"] });
MdbPopoverDirective.ctorParameters = () => [
    { type: Overlay },
    { type: OverlayPositionBuilder },
    { type: ElementRef }
];
MdbPopoverDirective.propDecorators = {
    mdbPopover: [{ type: Input }],
    mdbPopoverTitle: [{ type: Input }],
    popoverDisabled: [{ type: Input }],
    placement: [{ type: Input }],
    template: [{ type: Input }],
    animation: [{ type: Input }],
    trigger: [{ type: Input }],
    delayShow: [{ type: Input }],
    delayHide: [{ type: Input }],
    offset: [{ type: Input }],
    popoverShow: [{ type: Output }],
    popoverShown: [{ type: Output }],
    popoverHide: [{ type: Output }],
    popoverHidden: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbPopoverDirective, [{
        type: Directive,
        args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: '[mdbPopover]',
                exportAs: 'mdbPopover'
            }]
    }], function () { return [{ type: ɵngcc2.Overlay }, { type: ɵngcc2.OverlayPositionBuilder }, { type: ɵngcc0.ElementRef }]; }, { mdbPopover: [{
            type: Input
        }], mdbPopoverTitle: [{
            type: Input
        }], placement: [{
            type: Input
        }], trigger: [{
            type: Input
        }], delayShow: [{
            type: Input
        }], delayHide: [{
            type: Input
        }], offset: [{
            type: Input
        }], popoverShow: [{
            type: Output
        }], popoverShown: [{
            type: Output
        }], popoverHide: [{
            type: Output
        }], popoverHidden: [{
            type: Output
        }], popoverDisabled: [{
            type: Input
        }], animation: [{
            type: Input
        }], template: [{
            type: Input
        }] }); })();

class MdbPopoverModule {
}
MdbPopoverModule.ɵfac = function MdbPopoverModule_Factory(t) { return new (t || MdbPopoverModule)(); };
MdbPopoverModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MdbPopoverModule });
MdbPopoverModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, OverlayModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbPopoverModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, OverlayModule],
                declarations: [MdbPopoverDirective, MdbPopoverComponent],
                exports: [MdbPopoverDirective, MdbPopoverComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbPopoverModule, { declarations: function () { return [MdbPopoverDirective, MdbPopoverComponent]; }, imports: function () { return [CommonModule, OverlayModule]; }, exports: function () { return [MdbPopoverDirective, MdbPopoverComponent]; } }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { MdbPopoverDirective, MdbPopoverModule, MdbPopoverComponent as ɵa };

//# sourceMappingURL=mdb-angular-ui-kit-popover.js.map