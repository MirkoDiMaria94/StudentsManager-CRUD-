import { Component, ChangeDetectionStrategy, ChangeDetectorRef, Input, EventEmitter, Directive, ElementRef, Output, NgModule } from '@angular/core';
import { OverlayConfig, Overlay, OverlayPositionBuilder, OverlayModule } from '@angular/cdk/overlay';
import { ComponentPortal } from '@angular/cdk/portal';
import { trigger, state, style, transition, animate } from '@angular/animations';
import { Subject, fromEvent } from 'rxjs';
import { takeUntil, first } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/cdk/overlay';

function MdbTooltipComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵlistener("@fade.done", function MdbTooltipComponent_div_0_Template_div_animation_fade_done_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onAnimationEnd($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@fade", ctx_r0.animationState)("@.disabled", !ctx_r0.animation)("innerHTML", ctx_r0.title, ɵngcc0.ɵɵsanitizeHtml);
} }
function MdbTooltipComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵlistener("@fade.done", function MdbTooltipComponent_div_1_Template_div_animation_fade_done_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.onAnimationEnd($event); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@fade", ctx_r1.animationState)("@.disabled", !ctx_r1.animation);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.title, "\n");
} }
class MdbTooltipComponent {
    constructor(_cdRef) {
        this._cdRef = _cdRef;
        this._hidden = new Subject();
        this.animationState = 'hidden';
    }
    markForCheck() {
        this._cdRef.markForCheck();
    }
    onAnimationEnd(event) {
        if (event.toState === 'hidden') {
            this._hidden.next();
        }
    }
}
MdbTooltipComponent.ɵfac = function MdbTooltipComponent_Factory(t) { return new (t || MdbTooltipComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
MdbTooltipComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MdbTooltipComponent, selectors: [["mdb-tooltip"]], inputs: { title: "title", html: "html", animation: "animation" }, decls: 2, vars: 2, consts: [["class", "tooltip-inner", 3, "innerHTML", 4, "ngIf"], ["class", "tooltip-inner", 4, "ngIf"], [1, "tooltip-inner", 3, "innerHTML"], [1, "tooltip-inner"]], template: function MdbTooltipComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, MdbTooltipComponent_div_0_Template, 1, 3, "div", 0);
        ɵngcc0.ɵɵtemplate(1, MdbTooltipComponent_div_1_Template, 2, 3, "div", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.html);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.html);
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2, data: { animation: [
            trigger('fade', [
                state('visible', style({ opacity: 1 })),
                state('hidden', style({ opacity: 0 })),
                transition('visible => hidden', animate('150ms linear')),
                transition(':enter', animate('150ms linear')),
            ]),
        ] }, changeDetection: 0 });
MdbTooltipComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
MdbTooltipComponent.propDecorators = {
    title: [{ type: Input }],
    html: [{ type: Input }],
    animation: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbTooltipComponent, [{
        type: Component,
        args: [{
                selector: 'mdb-tooltip',
                template: "<div\n  *ngIf=\"html\"\n  [@fade]=\"animationState\"\n  (@fade.done)=\"onAnimationEnd($event)\"\n  [@.disabled]=\"!animation\"\n  [innerHTML]=\"title\"\n  class=\"tooltip-inner\"\n></div>\n<div\n  *ngIf=\"!html\"\n  [@fade]=\"animationState\"\n  (@fade.done)=\"onAnimationEnd($event)\"\n  [@.disabled]=\"!animation\"\n  class=\"tooltip-inner\"\n>\n  {{ title }}\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('fade', [
                        state('visible', style({ opacity: 1 })),
                        state('hidden', style({ opacity: 0 })),
                        transition('visible => hidden', animate('150ms linear')),
                        transition(':enter', animate('150ms linear')),
                    ]),
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { title: [{
            type: Input
        }], html: [{
            type: Input
        }], animation: [{
            type: Input
        }] }); })();

// eslint-disable-next-line @angular-eslint/component-class-suffix
class MdbTooltipDirective {
    constructor(_overlay, _overlayPositionBuilder, _elementRef) {
        this._overlay = _overlay;
        this._overlayPositionBuilder = _overlayPositionBuilder;
        this._elementRef = _elementRef;
        this.mdbTooltip = '';
        this.tooltipDisabled = false;
        this.placement = 'top';
        this.html = false;
        this.animation = true;
        this.trigger = 'hover focus';
        this.delayShow = 0;
        this.delayHide = 0;
        this.offset = 4;
        this.tooltipShow = new EventEmitter();
        this.tooltipShown = new EventEmitter();
        this.tooltipHide = new EventEmitter();
        this.tooltipHidden = new EventEmitter();
        this._open = false;
        this._showTimeout = 0;
        this._hideTimeout = 0;
        this._destroy$ = new Subject();
    }
    ngOnInit() {
        if (this.tooltipDisabled) {
            return;
        }
        this._bindTriggerEvents();
    }
    ngOnDestroy() {
        if (this._open || this._showTimeout) {
            this.hide();
        }
        this._destroy$.next();
        this._destroy$.complete();
    }
    _bindTriggerEvents() {
        const triggers = this.trigger.split(' ');
        triggers.forEach((trigger) => {
            if (trigger === 'click') {
                fromEvent(this._elementRef.nativeElement, trigger)
                    .pipe(takeUntil(this._destroy$))
                    .subscribe(() => this.toggle());
            }
            else if (trigger !== 'manual') {
                const evIn = trigger === 'hover' ? 'mouseenter' : 'focusin';
                const evOut = trigger === 'hover' ? 'mouseleave' : 'focusout';
                fromEvent(this._elementRef.nativeElement, evIn)
                    .pipe(takeUntil(this._destroy$))
                    .subscribe(() => this.show());
                fromEvent(this._elementRef.nativeElement, evOut)
                    .pipe(takeUntil(this._destroy$))
                    .subscribe(() => this.hide());
            }
        });
    }
    _createOverlayConfig() {
        const positionStrategy = this._overlayPositionBuilder
            .flexibleConnectedTo(this._elementRef)
            .withPositions(this._getPosition());
        const overlayConfig = new OverlayConfig({
            hasBackdrop: false,
            scrollStrategy: this._overlay.scrollStrategies.reposition(),
            positionStrategy,
        });
        return overlayConfig;
    }
    _createOverlay() {
        this._overlayRef = this._overlay.create(this._createOverlayConfig());
    }
    _getPosition() {
        let position;
        const positionTop = {
            originX: 'center',
            originY: 'top',
            overlayX: 'center',
            overlayY: 'bottom',
            offsetY: -this.offset,
        };
        const positionBottom = {
            originX: 'center',
            originY: 'bottom',
            overlayX: 'center',
            overlayY: 'top',
            offsetY: this.offset,
        };
        const positionRight = {
            originX: 'end',
            originY: 'center',
            overlayX: 'start',
            overlayY: 'center',
            offsetX: this.offset,
        };
        const positionLeft = {
            originX: 'start',
            originY: 'center',
            overlayX: 'end',
            overlayY: 'center',
            offsetX: -this.offset,
        };
        switch (this.placement) {
            case 'top':
                position = [positionTop, positionBottom];
                break;
            case 'bottom':
                position = [positionBottom, positionTop];
                break;
            case 'left':
                position = [positionLeft, positionRight];
                break;
            case 'right':
                position = [positionRight, positionLeft];
                break;
            default:
                break;
        }
        return position;
    }
    show() {
        if (this._hideTimeout || this._open) {
            this._overlayRef.detach();
            clearTimeout(this._hideTimeout);
            this._hideTimeout = null;
        }
        this._createOverlay();
        this._showTimeout = setTimeout(() => {
            const tooltipPortal = new ComponentPortal(MdbTooltipComponent);
            this.tooltipShow.emit(this);
            this._open = true;
            this._tooltipRef = this._overlayRef.attach(tooltipPortal);
            this._tooltipRef.instance.title = this.mdbTooltip;
            this._tooltipRef.instance.html = this.html;
            this._tooltipRef.instance.animation = this.animation;
            this._tooltipRef.instance.animationState = 'visible';
            this._tooltipRef.instance.markForCheck();
            this.tooltipShown.emit(this);
        }, this.delayShow);
    }
    hide() {
        if (this._showTimeout) {
            clearTimeout(this._showTimeout);
            this._showTimeout = null;
        }
        else {
            return;
        }
        this._hideTimeout = setTimeout(() => {
            this.tooltipHide.emit(this);
            if (!this._tooltipRef) {
                this._overlayRef.detach();
                this._open = false;
                this.tooltipHidden.emit(this);
            }
            else {
                this._tooltipRef.instance._hidden.pipe(first()).subscribe(() => {
                    this._overlayRef.detach();
                    this._open = false;
                    this.tooltipHidden.emit(this);
                });
                this._tooltipRef.instance.animationState = 'hidden';
                this._tooltipRef.instance.markForCheck();
            }
        }, this.delayHide);
    }
    toggle() {
        if (this._open) {
            this.hide();
        }
        else {
            this.show();
        }
    }
}
MdbTooltipDirective.ɵfac = function MdbTooltipDirective_Factory(t) { return new (t || MdbTooltipDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.OverlayPositionBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
MdbTooltipDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MdbTooltipDirective, selectors: [["", "mdbTooltip", ""]], inputs: { mdbTooltip: "mdbTooltip", tooltipDisabled: "tooltipDisabled", placement: "placement", html: "html", animation: "animation", trigger: "trigger", delayShow: "delayShow", delayHide: "delayHide", offset: "offset" }, outputs: { tooltipShow: "tooltipShow", tooltipShown: "tooltipShown", tooltipHide: "tooltipHide", tooltipHidden: "tooltipHidden" }, exportAs: ["mdbTooltip"] });
MdbTooltipDirective.ctorParameters = () => [
    { type: Overlay },
    { type: OverlayPositionBuilder },
    { type: ElementRef }
];
MdbTooltipDirective.propDecorators = {
    mdbTooltip: [{ type: Input }],
    tooltipDisabled: [{ type: Input }],
    placement: [{ type: Input }],
    html: [{ type: Input }],
    animation: [{ type: Input }],
    trigger: [{ type: Input }],
    delayShow: [{ type: Input }],
    delayHide: [{ type: Input }],
    offset: [{ type: Input }],
    tooltipShow: [{ type: Output }],
    tooltipShown: [{ type: Output }],
    tooltipHide: [{ type: Output }],
    tooltipHidden: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbTooltipDirective, [{
        type: Directive,
        args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: '[mdbTooltip]',
                exportAs: 'mdbTooltip'
            }]
    }], function () { return [{ type: ɵngcc2.Overlay }, { type: ɵngcc2.OverlayPositionBuilder }, { type: ɵngcc0.ElementRef }]; }, { mdbTooltip: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], placement: [{
            type: Input
        }], html: [{
            type: Input
        }], animation: [{
            type: Input
        }], trigger: [{
            type: Input
        }], delayShow: [{
            type: Input
        }], delayHide: [{
            type: Input
        }], offset: [{
            type: Input
        }], tooltipShow: [{
            type: Output
        }], tooltipShown: [{
            type: Output
        }], tooltipHide: [{
            type: Output
        }], tooltipHidden: [{
            type: Output
        }] }); })();

class MdbTooltipModule {
}
MdbTooltipModule.ɵfac = function MdbTooltipModule_Factory(t) { return new (t || MdbTooltipModule)(); };
MdbTooltipModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MdbTooltipModule });
MdbTooltipModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, OverlayModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbTooltipModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, OverlayModule],
                declarations: [MdbTooltipDirective, MdbTooltipComponent],
                exports: [MdbTooltipDirective, MdbTooltipComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbTooltipModule, { declarations: function () { return [MdbTooltipDirective, MdbTooltipComponent]; }, imports: function () { return [CommonModule, OverlayModule]; }, exports: function () { return [MdbTooltipDirective, MdbTooltipComponent]; } }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { MdbTooltipDirective, MdbTooltipModule, MdbTooltipComponent as ɵa };

//# sourceMappingURL=mdb-angular-ui-kit-tooltip.js.map