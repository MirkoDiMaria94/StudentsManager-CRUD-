import { Directive, ChangeDetectorRef, Inject, Input, HostBinding, HostListener, Injectable, EventEmitter, Component, ContentChildren, Output, ElementRef, Renderer2, NgZone, NgModule } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { Subject } from 'rxjs';
import { takeUntil, distinctUntilChanged } from 'rxjs/operators';

import * as ɵngcc0 from '@angular/core';

const _c0 = ["mdbScrollspy", ""];
const _c1 = ["*"];
class MdbScrollspyLinkDirective {
    constructor(cdRef, document) {
        this.cdRef = cdRef;
        this.document = document;
        this._scrollIntoView = true;
        this.scrollspyLink = true;
        this.active = false;
    }
    get scrollIntoView() {
        return this._scrollIntoView;
    }
    set scrollIntoView(value) {
        this._scrollIntoView = value;
    }
    get section() {
        return this._section;
    }
    set section(value) {
        if (value) {
            this._section = value;
        }
    }
    get id() {
        return this._id;
    }
    set id(newId) {
        if (newId) {
            this._id = newId;
        }
    }
    onClick() {
        if (this.section && this.scrollIntoView === true) {
            this.section.scrollIntoView();
        }
    }
    detectChanges() {
        this.cdRef.detectChanges();
    }
    assignSectionToId() {
        this.section = this.document.documentElement.querySelector(`#${this.id}`);
    }
    ngOnInit() {
        this.assignSectionToId();
    }
}
MdbScrollspyLinkDirective.ɵfac = function MdbScrollspyLinkDirective_Factory(t) { return new (t || MdbScrollspyLinkDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT)); };
MdbScrollspyLinkDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MdbScrollspyLinkDirective, selectors: [["", "mdbScrollspyLink", ""]], hostVars: 4, hostBindings: function MdbScrollspyLinkDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function MdbScrollspyLinkDirective_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("scrollspy-link", ctx.scrollspyLink)("active", ctx.active);
    } }, inputs: { scrollIntoView: "scrollIntoView", id: ["mdbScrollspyLink", "id"] } });
MdbScrollspyLinkDirective.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
MdbScrollspyLinkDirective.propDecorators = {
    scrollIntoView: [{ type: Input }],
    id: [{ type: Input, args: ['mdbScrollspyLink',] }],
    scrollspyLink: [{ type: HostBinding, args: ['class.scrollspy-link',] }],
    active: [{ type: HostBinding, args: ['class.active',] }],
    onClick: [{ type: HostListener, args: ['click', [],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbScrollspyLinkDirective, [{
        type: Directive,
        args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: '[mdbScrollspyLink]'
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, { scrollspyLink: [{
            type: HostBinding,
            args: ['class.scrollspy-link']
        }], active: [{
            type: HostBinding,
            args: ['class.active']
        }], scrollIntoView: [{
            type: Input
        }], id: [{
            type: Input,
            args: ['mdbScrollspyLink']
        }], onClick: [{
            type: HostListener,
            args: ['click', []]
        }] }); })();

class MdbScrollspyService {
    constructor() {
        this.scrollSpys = [];
        this.activeSubject = new Subject();
        this.active$ = this.activeSubject;
    }
    addScrollspy(scrollSpy) {
        this.scrollSpys.push(scrollSpy);
    }
    removeScrollspy(scrollSpyId) {
        const scrollSpyIndex = this.scrollSpys.findIndex((spy) => {
            return spy.id === scrollSpyId;
        });
        this.scrollSpys.splice(scrollSpyIndex, 1);
    }
    updateActiveState(scrollSpyId, activeLinkId) {
        const scrollSpy = this.scrollSpys.find((spy) => {
            return spy.id === scrollSpyId;
        });
        if (!scrollSpy) {
            return;
        }
        const activeLink = scrollSpy.links.find((link) => {
            return link.id === activeLinkId;
        });
        this.setActiveLink(activeLink);
    }
    removeActiveState(scrollSpyId, activeLinkId) {
        const scrollSpy = this.scrollSpys.find((spy) => {
            return spy.id === scrollSpyId;
        });
        if (!scrollSpy) {
            return;
        }
        const activeLink = scrollSpy.links.find((link) => {
            return link.id === activeLinkId;
        });
        if (!activeLink) {
            return;
        }
        activeLink.active = false;
        activeLink.detectChanges();
    }
    setActiveLink(activeLink) {
        if (activeLink) {
            activeLink.active = true;
            activeLink.detectChanges();
            this.activeSubject.next(activeLink);
        }
    }
    removeActiveLinks(scrollSpyId) {
        const scrollSpy = this.scrollSpys.find((spy) => {
            return spy.id === scrollSpyId;
        });
        if (!scrollSpy) {
            return;
        }
        scrollSpy.links.forEach((link) => {
            link.active = false;
            link.detectChanges();
        });
    }
}
MdbScrollspyService.ɵfac = function MdbScrollspyService_Factory(t) { return new (t || MdbScrollspyService)(); };
MdbScrollspyService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: MdbScrollspyService, factory: MdbScrollspyService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbScrollspyService, [{
        type: Injectable
    }], function () { return []; }, null); })();

// eslint-disable-next-line @angular-eslint/component-class-suffix
class MdbScrollspyDirective {
    constructor(scrollSpyService) {
        this.scrollSpyService = scrollSpyService;
        this._destroy$ = new Subject();
        this.activeLinkChange = new EventEmitter();
    }
    get id() {
        return this._id;
    }
    set id(newId) {
        if (newId) {
            this._id = newId;
        }
    }
    ngOnInit() {
        this.activeSub = this.scrollSpyService.active$
            .pipe(takeUntil(this._destroy$), distinctUntilChanged())
            .subscribe((activeLink) => {
            this.activeLinkChange.emit(activeLink);
        });
    }
    ngAfterContentInit() {
        this.scrollSpyService.addScrollspy({ id: this.id, links: this.links });
    }
    ngOnDestroy() {
        this.scrollSpyService.removeScrollspy(this.id);
        this._destroy$.next();
        this._destroy$.complete();
    }
}
MdbScrollspyDirective.ɵfac = function MdbScrollspyDirective_Factory(t) { return new (t || MdbScrollspyDirective)(ɵngcc0.ɵɵdirectiveInject(MdbScrollspyService)); };
MdbScrollspyDirective.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MdbScrollspyDirective, selectors: [["", "mdbScrollspy", ""]], contentQueries: function MdbScrollspyDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, MdbScrollspyLinkDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.links = _t);
    } }, inputs: { id: ["mdbScrollspy", "id"] }, outputs: { activeLinkChange: "activeLinkChange" }, attrs: _c0, ngContentSelectors: _c1, decls: 1, vars: 0, template: function MdbScrollspyDirective_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
MdbScrollspyDirective.ctorParameters = () => [
    { type: MdbScrollspyService }
];
MdbScrollspyDirective.propDecorators = {
    links: [{ type: ContentChildren, args: [MdbScrollspyLinkDirective, { descendants: true },] }],
    id: [{ type: Input, args: ['mdbScrollspy',] }],
    activeLinkChange: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbScrollspyDirective, [{
        type: Component,
        args: [{
                // eslint-disable-next-line @angular-eslint/component-selector
                selector: '[mdbScrollspy]',
                template: '<ng-content></ng-content>'
            }]
    }], function () { return [{ type: MdbScrollspyService }]; }, { activeLinkChange: [{
            type: Output
        }], id: [{
            type: Input,
            args: ['mdbScrollspy']
        }], links: [{
            type: ContentChildren,
            args: [MdbScrollspyLinkDirective, { descendants: true }]
        }] }); })();

// eslint-disable-next-line @angular-eslint/directive-class-suffix
class MdbScrollspyElementDirective {
    constructor(_elementRef, renderer, ngZone, scrollSpyService) {
        this._elementRef = _elementRef;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.scrollSpyService = scrollSpyService;
        this.offset = 0;
    }
    get host() {
        return this._elementRef.nativeElement;
    }
    get scrollSpyId() {
        return this._scrollSpyId;
    }
    set scrollSpyId(newId) {
        if (newId) {
            this._scrollSpyId = newId;
        }
    }
    isElementInViewport() {
        const scrollTop = this.container.scrollTop;
        const elTop = this.host.offsetTop - this.offset;
        const elHeight = this.host.offsetHeight;
        return scrollTop >= elTop && scrollTop < elTop + elHeight;
    }
    updateActiveState(scrollSpyId, id) {
        if (this.isElementInViewport()) {
            this.scrollSpyService.removeActiveLinks(scrollSpyId);
            this.scrollSpyService.updateActiveState(scrollSpyId, id);
        }
    }
    onScroll() {
        this.updateActiveState(this.scrollSpyId, this.id);
    }
    listenToScroll() {
        this.renderer.listen(this.container, 'scroll', () => {
            this.onScroll();
        });
    }
    ngOnInit() {
        this.id = this.host.id;
        if (!this.container) {
            this.container = this._getClosestEl(this.host, '.scrollspy-container');
        }
        this.renderer.setStyle(this.container, 'position', 'relative');
        this.ngZone.runOutsideAngular(this.listenToScroll.bind(this));
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.updateActiveState(this.scrollSpyId, this.id);
        }, 0);
    }
    _getClosestEl(el, selector) {
        for (; el && el !== document; el = el.parentNode) {
            if (el.matches && el.matches(selector)) {
                return el;
            }
        }
        return null;
    }
}
MdbScrollspyElementDirective.ɵfac = function MdbScrollspyElementDirective_Factory(t) { return new (t || MdbScrollspyElementDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MdbScrollspyService)); };
MdbScrollspyElementDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MdbScrollspyElementDirective, selectors: [["", "mdbScrollspyElement", ""]], inputs: { offset: "offset", scrollSpyId: ["mdbScrollspyElement", "scrollSpyId"], container: "container" } });
MdbScrollspyElementDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone },
    { type: MdbScrollspyService }
];
MdbScrollspyElementDirective.propDecorators = {
    container: [{ type: Input }],
    scrollSpyId: [{ type: Input, args: ['mdbScrollspyElement',] }],
    offset: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbScrollspyElementDirective, [{
        type: Directive,
        args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: '[mdbScrollspyElement]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: MdbScrollspyService }]; }, { offset: [{
            type: Input
        }], scrollSpyId: [{
            type: Input,
            args: ['mdbScrollspyElement']
        }], container: [{
            type: Input
        }] }); })();

class MdbScrollspyWindowDirective {
    constructor(document, el, renderer, ngZone, scrollSpyService) {
        this.document = document;
        this.el = el;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.scrollSpyService = scrollSpyService;
        this.offset = 0;
    }
    get scrollSpyId() {
        return this._scrollSpyId;
    }
    set scrollSpyId(newId) {
        if (newId) {
            this._scrollSpyId = newId;
        }
    }
    isElementInViewport() {
        const scrollTop = this.document.documentElement.scrollTop || this.document.body.scrollTop;
        const elHeight = this.el.nativeElement.offsetHeight;
        const elTop = this.el.nativeElement.offsetTop - this.offset;
        const elBottom = elTop + elHeight;
        return scrollTop >= elTop && scrollTop <= elBottom;
    }
    updateActiveState(scrollSpyId, id) {
        if (this.isElementInViewport()) {
            this.scrollSpyService.updateActiveState(scrollSpyId, id);
        }
        else {
            this.scrollSpyService.removeActiveState(scrollSpyId, id);
        }
    }
    onScroll() {
        this.updateActiveState(this.scrollSpyId, this.id);
    }
    listenToScroll() {
        this.renderer.listen(window, 'scroll', () => {
            this.onScroll();
        });
    }
    ngOnInit() {
        this.id = this.el.nativeElement.id;
        this.ngZone.runOutsideAngular(this.listenToScroll.bind(this));
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.updateActiveState(this.scrollSpyId, this.id);
        }, 0);
    }
}
MdbScrollspyWindowDirective.ɵfac = function MdbScrollspyWindowDirective_Factory(t) { return new (t || MdbScrollspyWindowDirective)(ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MdbScrollspyService)); };
MdbScrollspyWindowDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MdbScrollspyWindowDirective, selectors: [["", "mdbScrollspyWindow", ""]], inputs: { offset: "offset", scrollSpyId: ["mdbScrollspyWindow", "scrollSpyId"] } });
MdbScrollspyWindowDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone },
    { type: MdbScrollspyService }
];
MdbScrollspyWindowDirective.propDecorators = {
    scrollSpyId: [{ type: Input, args: ['mdbScrollspyWindow',] }],
    offset: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbScrollspyWindowDirective, [{
        type: Directive,
        args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: '[mdbScrollspyWindow]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: MdbScrollspyService }]; }, { offset: [{
            type: Input
        }], scrollSpyId: [{
            type: Input,
            args: ['mdbScrollspyWindow']
        }] }); })();

class MdbScrollspyModule {
}
MdbScrollspyModule.ɵfac = function MdbScrollspyModule_Factory(t) { return new (t || MdbScrollspyModule)(); };
MdbScrollspyModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MdbScrollspyModule });
MdbScrollspyModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [MdbScrollspyService] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbScrollspyModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    MdbScrollspyDirective,
                    MdbScrollspyLinkDirective,
                    MdbScrollspyElementDirective,
                    MdbScrollspyWindowDirective,
                ],
                exports: [
                    MdbScrollspyDirective,
                    MdbScrollspyLinkDirective,
                    MdbScrollspyElementDirective,
                    MdbScrollspyWindowDirective,
                ],
                providers: [MdbScrollspyService]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbScrollspyModule, { declarations: [MdbScrollspyDirective, MdbScrollspyLinkDirective, MdbScrollspyElementDirective, MdbScrollspyWindowDirective], exports: [MdbScrollspyDirective, MdbScrollspyLinkDirective, MdbScrollspyElementDirective, MdbScrollspyWindowDirective] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { MdbScrollspyDirective, MdbScrollspyElementDirective, MdbScrollspyLinkDirective, MdbScrollspyModule, MdbScrollspyService, MdbScrollspyWindowDirective };

//# sourceMappingURL=mdb-angular-ui-kit-scrollspy.js.map