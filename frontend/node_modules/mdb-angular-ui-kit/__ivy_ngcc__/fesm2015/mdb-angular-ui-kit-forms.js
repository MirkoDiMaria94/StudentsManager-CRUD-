import { Directive, Component, ChangeDetectionStrategy, Renderer2, ElementRef, NgZone, ViewChild, ContentChild, HostBinding, Optional, Self, Input, HostListener, NgModule } from '@angular/core';
import { ContentObserver } from '@angular/cdk/observers';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { NgControl, FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';

// eslint-disable-next-line @angular-eslint/directive-class-suffix
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/observers';
import * as ɵngcc2 from '@angular/forms';

const _c0 = ["notchLeading"];
const _c1 = ["notchMiddle"];
const _c2 = ["*"];
class MdbAbstractFormControl {
}
MdbAbstractFormControl.ɵfac = function MdbAbstractFormControl_Factory(t) { return new (t || MdbAbstractFormControl)(); };
MdbAbstractFormControl.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MdbAbstractFormControl });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbAbstractFormControl, [{
        type: Directive
    }], null, null); })();

// eslint-disable-next-line @angular-eslint/component-class-suffix
class MdbLabelDirective {
    constructor() { }
}
MdbLabelDirective.ɵfac = function MdbLabelDirective_Factory(t) { return new (t || MdbLabelDirective)(); };
MdbLabelDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MdbLabelDirective, selectors: [["", "mdbLabel", ""]], exportAs: ["mdbLabel"] });
MdbLabelDirective.ctorParameters = () => [];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbLabelDirective, [{
        type: Directive,
        args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: '[mdbLabel]',
                exportAs: 'mdbLabel'
            }]
    }], function () { return []; }, null); })();

class MdbFormControlComponent {
    constructor(_renderer, _contentObserver, _elementRef, _ngZone) {
        this._renderer = _renderer;
        this._contentObserver = _contentObserver;
        this._elementRef = _elementRef;
        this._ngZone = _ngZone;
        this.outline = true;
        this._destroy$ = new Subject();
        this._notchLeadingLength = 9;
        this._labelMarginLeft = 0;
        this._labelGapPadding = 8;
        this._labelScale = 0.8;
        this._recalculateGapWhenVisible = false;
    }
    get input() {
        return this._formControl.input;
    }
    ngAfterContentInit() {
        if (this._label) {
            this._updateBorderGap();
        }
        else {
            this._renderer.addClass(this.input, 'placeholder-active');
        }
        this._updateLabelActiveState();
        if (this._label) {
            this._contentObserver
                .observe(this._label.nativeElement)
                .pipe(takeUntil(this._destroy$))
                .subscribe(() => {
                this._updateBorderGap();
            });
        }
        this._formControl.stateChanges.pipe(takeUntil(this._destroy$)).subscribe(() => {
            this._updateLabelActiveState();
            if (this._label) {
                this._updateBorderGap();
            }
        });
        this._ngZone.runOutsideAngular(() => {
            this._ngZone.onStable.pipe(takeUntil(this._destroy$)).subscribe(() => {
                if (this._label && this._recalculateGapWhenVisible) {
                    this._updateBorderGap();
                }
            });
        });
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.unsubscribe();
    }
    _getLabelWidth() {
        return this._label.nativeElement.clientWidth * this._labelScale + this._labelGapPadding;
    }
    _updateBorderGap() {
        // Element is in DOM but is not visible, we need to recalculate the gap when element
        // is displayed. This problem may occur in components such as tabs where content of
        // inactive tabs has display:none styles
        if (this._isHidden()) {
            this._recalculateGapWhenVisible = true;
            return;
        }
        const notchLeadingWidth = `${this._labelMarginLeft + this._notchLeadingLength}px`;
        const notchMiddleWidth = `${this._getLabelWidth()}px`;
        this._notchLeading.nativeElement.style.width = notchLeadingWidth;
        this._notchMiddle.nativeElement.style.width = notchMiddleWidth;
        this._label.nativeElement.style.marginLeft = `${this._labelMarginLeft}px`;
        this._recalculateGapWhenVisible = false;
    }
    _updateLabelActiveState() {
        if (this._isLabelActive()) {
            this._renderer.addClass(this.input, 'active');
        }
        else {
            this._renderer.removeClass(this.input, 'active');
        }
    }
    _isLabelActive() {
        return this._formControl && this._formControl.labelActive;
    }
    _isHidden() {
        const el = this._elementRef.nativeElement;
        return !el.offsetHeight && !el.offsetWidth;
    }
}
MdbFormControlComponent.ɵfac = function MdbFormControlComponent_Factory(t) { return new (t || MdbFormControlComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ContentObserver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MdbFormControlComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MdbFormControlComponent, selectors: [["mdb-form-control"]], contentQueries: function MdbFormControlComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, MdbAbstractFormControl, 7);
        ɵngcc0.ɵɵcontentQuery(dirIndex, MdbLabelDirective, 7, ElementRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._formControl = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._label = _t.first);
    } }, viewQuery: function MdbFormControlComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 7);
        ɵngcc0.ɵɵviewQuery(_c1, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._notchLeading = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._notchMiddle = _t.first);
    } }, hostVars: 2, hostBindings: function MdbFormControlComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("form-outline", ctx.outline);
    } }, ngContentSelectors: _c2, decls: 7, vars: 0, consts: [[1, "form-notch"], [1, "form-notch-leading"], ["notchLeading", ""], [1, "form-notch-middle"], ["notchMiddle", ""], [1, "form-notch-trailing"]], template: function MdbFormControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "div", 0);
        ɵngcc0.ɵɵelement(2, "div", 1, 2);
        ɵngcc0.ɵɵelement(4, "div", 3, 4);
        ɵngcc0.ɵɵelement(6, "div", 5);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2, changeDetection: 0 });
MdbFormControlComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ContentObserver },
    { type: ElementRef },
    { type: NgZone }
];
MdbFormControlComponent.propDecorators = {
    _notchLeading: [{ type: ViewChild, args: ['notchLeading', { static: true },] }],
    _notchMiddle: [{ type: ViewChild, args: ['notchMiddle', { static: true },] }],
    _formControl: [{ type: ContentChild, args: [MdbAbstractFormControl, { static: true },] }],
    _label: [{ type: ContentChild, args: [MdbLabelDirective, { static: true, read: ElementRef },] }],
    outline: [{ type: HostBinding, args: ['class.form-outline',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbFormControlComponent, [{
        type: Component,
        args: [{
                selector: 'mdb-form-control',
                template: "<ng-content></ng-content>\n<div class=\"form-notch\">\n  <div #notchLeading class=\"form-notch-leading\"></div>\n  <div #notchMiddle class=\"form-notch-middle\"></div>\n  <div class=\"form-notch-trailing\"></div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc1.ContentObserver }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { outline: [{
            type: HostBinding,
            args: ['class.form-outline']
        }], _notchLeading: [{
            type: ViewChild,
            args: ['notchLeading', { static: true }]
        }], _notchMiddle: [{
            type: ViewChild,
            args: ['notchMiddle', { static: true }]
        }], _formControl: [{
            type: ContentChild,
            args: [MdbAbstractFormControl, { static: true }]
        }], _label: [{
            type: ContentChild,
            args: [MdbLabelDirective, { static: true, read: ElementRef }]
        }] }); })();

// eslint-disable-next-line @angular-eslint/component-class-suffix
class MdbInputDirective {
    constructor(_elementRef, _renderer, _ngControl) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._ngControl = _ngControl;
        this.stateChanges = new Subject();
        this._focused = false;
        this._disabled = false;
        this._readonly = false;
    }
    get disabled() {
        if (this._ngControl && this._ngControl.disabled !== null) {
            return this._ngControl.disabled;
        }
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
    }
    get readonly() {
        return this._readonly;
    }
    set readonly(value) {
        if (value) {
            this._renderer.setAttribute(this._elementRef.nativeElement, 'readonly', '');
        }
        else {
            this._renderer.removeAttribute(this._elementRef.nativeElement, 'readonly');
        }
        this._readonly = coerceBooleanProperty(value);
    }
    get value() {
        return this._elementRef.nativeElement.value;
    }
    set value(value) {
        if (value !== this.value) {
            this._elementRef.nativeElement.value = value;
            this._value = value;
            this.stateChanges.next();
        }
    }
    _onFocus() {
        this._focused = true;
        this.stateChanges.next();
    }
    _onBlur() {
        this._focused = false;
        this.stateChanges.next();
    }
    ngDoCheck() {
        const value = this._elementRef.nativeElement.value;
        if (this._currentNativeValue !== value) {
            this._currentNativeValue = value;
            this.stateChanges.next();
        }
    }
    get hasValue() {
        return this._elementRef.nativeElement.value !== '';
    }
    get focused() {
        return this._focused;
    }
    get input() {
        return this._elementRef.nativeElement;
    }
    get labelActive() {
        return this.focused || this.hasValue;
    }
}
MdbInputDirective.ɵfac = function MdbInputDirective_Factory(t) { return new (t || MdbInputDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl, 10)); };
MdbInputDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MdbInputDirective, selectors: [["", "mdbInput", ""]], hostVars: 1, hostBindings: function MdbInputDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focus", function MdbInputDirective_focus_HostBindingHandler() { return ctx._onFocus(); })("blur", function MdbInputDirective_blur_HostBindingHandler() { return ctx._onBlur(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("disabled", ctx.disabled);
    } }, inputs: { disabled: "disabled", readonly: "readonly", value: "value" }, exportAs: ["mdbInput"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: MdbAbstractFormControl, useExisting: MdbInputDirective }])] });
MdbInputDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }] }
];
MdbInputDirective.propDecorators = {
    disabled: [{ type: HostBinding, args: ['disabled',] }, { type: Input, args: ['disabled',] }],
    readonly: [{ type: Input, args: ['readonly',] }],
    value: [{ type: Input }],
    _onFocus: [{ type: HostListener, args: ['focus',] }],
    _onBlur: [{ type: HostListener, args: ['blur',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbInputDirective, [{
        type: Directive,
        args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: '[mdbInput]',
                exportAs: 'mdbInput',
                providers: [{ provide: MdbAbstractFormControl, useExisting: MdbInputDirective }]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc2.NgControl, decorators: [{
                type: Optional
            }, {
                type: Self
            }] }]; }, { disabled: [{
            type: HostBinding,
            args: ['disabled']
        }, {
            type: Input,
            args: ['disabled']
        }], readonly: [{
            type: Input,
            args: ['readonly']
        }], value: [{
            type: Input
        }], _onFocus: [{
            type: HostListener,
            args: ['focus']
        }], _onBlur: [{
            type: HostListener,
            args: ['blur']
        }] }); })();

class MdbFormsModule {
}
MdbFormsModule.ɵfac = function MdbFormsModule_Factory(t) { return new (t || MdbFormsModule)(); };
MdbFormsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MdbFormsModule });
MdbFormsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, FormsModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MdbFormsModule, [{
        type: NgModule,
        args: [{
                declarations: [MdbFormControlComponent, MdbInputDirective, MdbLabelDirective],
                exports: [MdbFormControlComponent, MdbInputDirective, MdbLabelDirective],
                imports: [CommonModule, FormsModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbFormsModule, { declarations: function () { return [MdbFormControlComponent, MdbInputDirective, MdbLabelDirective]; }, imports: function () { return [CommonModule, FormsModule]; }, exports: function () { return [MdbFormControlComponent, MdbInputDirective, MdbLabelDirective]; } }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { MdbAbstractFormControl, MdbFormControlComponent, MdbFormsModule, MdbInputDirective, MdbLabelDirective };

//# sourceMappingURL=mdb-angular-ui-kit-forms.js.map